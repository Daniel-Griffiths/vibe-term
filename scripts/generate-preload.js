#!/usr/bin/env node

/**
 * Auto-generates preload.ts from IPC handler definitions
 * This eliminates the need to manually sync handler names between files
 */

import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const projectRoot = path.join(__dirname, "..");

// Parse IPC handlers from ipc-handlers.ts and add hardcoded event listeners
function parseIPCHandlers() {
  const ipcHandlersPath = path.join(projectRoot, "electron/ipc-handlers.ts");
  const content = fs.readFileSync(ipcHandlersPath, "utf8");

  // Extract all registerIPCHandler calls
  const handlerMatches = content.matchAll(
    /registerIPCHandler[^(]*\(\s*['"](.*?)['"][^)]*\)/g
  );
  const handlers = [];

  for (const match of handlerMatches) {
    const handlerName = match[1];

    handlers.push({
      name: handlerName,
      isEventListener: false,
      // Convert kebab-case to camelCase for API method names
      apiName: handlerName.replace(/-([a-z])/g, (_, letter) =>
        letter.toUpperCase()
      ),
    });
  }

  // Add hardcoded event listeners that are used in the app
  const eventListeners = [
    { name: 'terminal-output', apiName: 'onTerminalOutput' },
    { name: 'process-exit', apiName: 'onProcessExit' },
    { name: 'claude-ready', apiName: 'onClaudeReady' },
    { name: 'claude-working', apiName: 'onClaudeWorking' },
    { name: 'background-output', apiName: 'onBackgroundOutput' },
    { name: 'missing-dependencies', apiName: 'onMissingDependencies' },
    { name: 'main-process-ready', apiName: 'onMainProcessReady' }
  ];
  
  eventListeners.forEach(listener => {
    handlers.push({
      ...listener,
      isEventListener: true
    });
  });

  return handlers;
}

// Generate preload.ts content
function generatePreloadContent(handlers) {
  const invokeHandlers = handlers.filter((h) => !h.isEventListener);
  const eventHandlers = handlers.filter((h) => h.isEventListener);

  const invokeContent = invokeHandlers
    .map(
      (handler) =>
        `  ${handler.apiName}: (...args: any[]) => 
    ipcRenderer.invoke('${handler.name}', ...args),`
    )
    .join("\n\n");

  const eventContent = eventHandlers
    .map(
      (handler) =>
        `  ${handler.apiName}: (callback: (data: any) => void) => {
    ipcRenderer.on('${handler.name}', (event, data) => {
      console.log(\`[Preload Debug] Received ${handler.name} in preload:\`, {
        projectId: data?.projectId,
        dataLength: data?.data?.length,
        dataPreview: data?.data?.substring?.(0, 50)
      });
      callback(data);
    });
    return () => ipcRenderer.removeAllListeners('${handler.name}');
  },`
    )
    .join("\n\n");

  return `/**
 * This file is AUTO-GENERATED by scripts/generate-preload.js
 * Do not edit manually - run the script to regenerate.
 */

import { contextBridge, ipcRenderer } from 'electron';

contextBridge.exposeInMainWorld('electronAPI', {
${invokeContent}${eventHandlers.length > 0 ? "\n\n" + eventContent : ""}
});

export {};
`;
}

// Main execution
function main() {
  console.log("ğŸ”§ Generating preload.ts from IPC handler definitions...");

  try {
    const handlers = parseIPCHandlers();
    console.log(`ğŸ“ Found ${handlers.length} IPC handlers`);

    const preloadContent = generatePreloadContent(handlers);
    const preloadPath = path.join(projectRoot, "electron/preload.ts");

    // Backup existing preload.ts
    if (fs.existsSync(preloadPath)) {
      fs.copyFileSync(preloadPath, `${preloadPath}.backup`);
      console.log("ğŸ’¾ Backed up existing preload.ts");
    }

    fs.writeFileSync(preloadPath, preloadContent);
    console.log("âœ… Generated electron/preload.ts successfully");

    console.log("\nğŸ“‹ Generated API methods:");
    handlers.forEach((h) => {
      const type = h.isEventListener ? "ğŸ“¡ Event" : "ğŸ“ Invoke";
      console.log(`  ${type}: ${h.apiName} (${h.name})`);
    });
  } catch (error) {
    console.error("âŒ Error generating preload.ts:", error);
    process.exit(1);
  }
}

main();
