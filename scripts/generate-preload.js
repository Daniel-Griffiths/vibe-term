#!/usr/bin/env node

/**
 * Auto-generates preload.ts from IPC handler definitions
 * This eliminates the need to manually sync handler names between files
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const projectRoot = path.join(__dirname, '..');

// Parse IPC handlers from ipc-handlers.ts and original preload.ts
function parseIPCHandlers() {
  const ipcHandlersPath = path.join(projectRoot, 'electron/ipc-handlers.ts');
  const content = fs.readFileSync(ipcHandlersPath, 'utf8');
  
  // Extract all registerIPCHandler calls
  const handlerMatches = content.matchAll(/registerIPCHandler[^(]*\(\s*['"](.*?)['"][^)]*\)/g);
  const handlers = [];
  
  for (const match of handlerMatches) {
    const handlerName = match[1];
    
    handlers.push({
      name: handlerName,
      isEventListener: false,
      // Convert kebab-case to camelCase for API method names
      apiName: handlerName.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase())
    });
  }
  
  // Also parse event listeners from the original preload.ts backup
  const preloadBackupPath = path.join(projectRoot, 'electron/preload.ts.backup');
  if (fs.existsSync(preloadBackupPath)) {
    const preloadContent = fs.readFileSync(preloadBackupPath, 'utf8');
    
    // Extract event listener methods (those that use ipcRenderer.on)
    const eventMatches = preloadContent.matchAll(/(\w+):\s*\(callback.*?\)\s*=>\s*{\s*ipcRenderer\.on\(['"]([^'"]+)['"]/g);
    
    for (const match of eventMatches) {
      const apiName = match[1];
      const eventName = match[2];
      
      handlers.push({
        name: eventName,
        isEventListener: true,
        apiName: apiName
      });
    }
  }
  
  return handlers;
}

// Generate preload.ts content
function generatePreloadContent(handlers) {
  const invokeHandlers = handlers.filter(h => !h.isEventListener);
  const eventHandlers = handlers.filter(h => h.isEventListener);
  
  const invokeContent = invokeHandlers.map(handler => 
    `  ${handler.apiName}: (...args: any[]) => 
    ipcRenderer.invoke('${handler.name}', ...args),`
  ).join('\n\n');

  const eventContent = eventHandlers.map(handler => 
    `  ${handler.apiName}: (callback: (data: any) => void) => {
    ipcRenderer.on('${handler.name}', (event, data) => {
      console.log(\`[Preload Debug] Received ${handler.name} in preload:\`, {
        projectId: data?.projectId,
        dataLength: data?.data?.length,
        dataPreview: data?.data?.substring?.(0, 50)
      });
      callback(data);
    });
    return () => ipcRenderer.removeAllListeners('${handler.name}');
  },`
  ).join('\n\n');
  
  return `import { contextBridge, ipcRenderer } from 'electron';

// Auto-generated from IPC handler definitions
// DO NOT EDIT MANUALLY - this file is generated by scripts/generate-preload.js

contextBridge.exposeInMainWorld('electronAPI', {
${invokeContent}${eventHandlers.length > 0 ? '\n\n' + eventContent : ''}
});

export {};
`;
}

// Main execution
function main() {
  console.log('🔧 Generating preload.ts from IPC handler definitions...');
  
  try {
    const handlers = parseIPCHandlers();
    console.log(`📝 Found ${handlers.length} IPC handlers`);
    
    const preloadContent = generatePreloadContent(handlers);
    const preloadPath = path.join(projectRoot, 'electron/preload.ts');
    
    // Backup existing preload.ts
    if (fs.existsSync(preloadPath)) {
      fs.copyFileSync(preloadPath, `${preloadPath}.backup`);
      console.log('💾 Backed up existing preload.ts');
    }
    
    fs.writeFileSync(preloadPath, preloadContent);
    console.log('✅ Generated electron/preload.ts successfully');
    
    console.log('\n📋 Generated API methods:');
    handlers.forEach(h => {
      const type = h.isEventListener ? '📡 Event' : '📞 Invoke';
      console.log(`  ${type}: ${h.apiName} (${h.name})`);
    });
    
  } catch (error) {
    console.error('❌ Error generating preload.ts:', error);
    process.exit(1);
  }
}

main();